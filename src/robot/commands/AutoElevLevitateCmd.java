// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;
import robot.commands.DriveArcCmd.DriveDir;
import robot.commands.DriveArcCmd.DriveState;

/**
 *
 */
public class AutoElevLevitateCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    public static final double RAISEPWR = -0.80;	
    public static final double HOLDPWR  = -0.18;   
    public static final double ELEVCLIMBVALUE = 7;
    
    private double mCurrPos, mTgtPos;
    private String line;
      
    public enum DriveState { START, DRIVING, HOLDING, DONE };
    private DriveState mDriveState = DriveState.START;	// this keeps track of our current drive mode

    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public AutoElevLevitateCmd() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.elevSubSys);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	mCurrPos = Robot.elevSubSys.getElevPos();
    	mTgtPos = ELEVCLIMBVALUE;
    	line = "AutoElevLevitateCmd Init!   Target=" + mTgtPos + "  (CurrPos=" + mCurrPos + ")";
    	line += " RaisePwr=" + RAISEPWR + "  HoldPwr=" + HOLDPWR;
    	System.out.println(line) ;
    	Robot.logger.appendLog(line);
    	
    	mDriveState = DriveState.START;
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	mCurrPos = Robot.elevSubSys.getElevPos();
    	if (mDriveState == DriveState.START) {
    		if (mCurrPos < mTgtPos){
    			// we are starting too low so just get out
    			mDriveState = DriveState.DONE;
    			return;
    		} else {
    			mDriveState = DriveState.DRIVING;    			
    		}
    	}
    	
    	if (mDriveState == DriveState.DRIVING) {
    		if (mCurrPos <= mTgtPos){
    			// we are the ending spot so go to hold
    			mDriveState = DriveState.HOLDING;    			
    		}
    	}
    	
    	if (mDriveState == DriveState.DRIVING) Robot.elevSubSys.elevMoveMtr(RAISEPWR);
    	if (mDriveState == DriveState.HOLDING) Robot.elevSubSys.elevMoveMtr(HOLDPWR);    		

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if ( mDriveState == DriveState.DONE)
    		// Only exit if started below climb position
    		return true;
    	else	
    		// Otherwise continue climbing or Holding unless interrupted
    		return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	Robot.elevSubSys.elevStopMtr();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
