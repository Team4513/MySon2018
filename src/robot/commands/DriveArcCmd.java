// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;
import robot.commands.DriveArcTurnCmd.DriveDir;
import robot.commands.DriveArcTurnCmd.DriveMode;
import robot.commands.DriveArcTurnCmd.DriveState;
import robot.commands.DriveArcTurnCmd.TurnDir;
import robot.utils.PositionTracker;
import robot.utils.SimpleArcFollower;
import robot.utils.SimpleArcFollower.FollowArcOutput;

/**
 *
 */
public class DriveArcCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_Radius;
    private double m_CtrX;
    private double m_CtrY;
    private double m_EndYaw;
    private double m_BasePwr;
    private double m_Kp;
    private double m_TO;
    private double  m_EndX; 
    private double  m_EndY; 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    String line;

    Timer startTmr = new Timer();
    double START_TIME = 0.08;							// Time to wait for motors to start moving robot
    int stallCtr = 0;
    final double STALL_VELOCITY = 1.0;					// Speed less than this will indicate stopped
    final double STOP_LEFT_PWR  = - 0.15;				// Power to reverse motors to brake
    final double STOP_RIGHT_PWR  = - 0.15;				// Power to reverse motors to brake
    int driveProfileFlag, stopFlag;
    double currPwr,currLeftPwr,currRightPwr, currLeftStopPwr, currRightStopPwr;
    double tgtYaw, tgtYawDir;
    double m_RemainTgtDist, m_RemainTgtYaw, currDist, currYaw, currSpeed;
    char m_Zone;
    int zoneNum;
    double currX, currY, currZ;
    
    boolean m_BrakeFlag = false;			// ** Later add this to a passed parameter
  
    SimpleArcFollower mArcFollower;
    SimpleArcFollower.FollowArcOutput m_FollowArcOutput = new SimpleArcFollower.FollowArcOutput();
    
    public enum DriveMode { DIST, HDG };
    private DriveMode mDriveMode = DriveMode.DIST;	// this keeps track of our current drive mode
    
    public enum DriveState { START, DRIVING, BRAKING, STALLED, ATEND, DONE };
    private DriveState mDriveState = DriveState.START;	// this keeps track of our current drive mode
    
    public enum DriveDir { FWD, REV };
    private DriveDir mDriveDir = DriveDir.FWD;	// this keeps track of our current drive direction
    
    public enum TurnDir { RIGHT, LEFT };
    private TurnDir mTurnDir = TurnDir.RIGHT;	// this keeps track of our current turn direction

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveArcCmd(double Radius, double CtrX, double CtrY, double EndYaw, double BasePwr, double Kp, double TO, double EndX, double EndY) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_Radius = Radius;
        m_CtrX = CtrX;
        m_CtrY = CtrY;
        m_EndYaw = EndYaw;
        m_BasePwr = BasePwr;
        m_Kp = Kp;
        m_TO = TO;
        m_EndX = EndX;        
        m_EndY = EndY; 

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = " ********** Starting DriveArcCmd ***********";
    	line +=  " Radius=" + m_Radius + " CtrX=" + m_CtrX;    	
    	line +=  " CtrY=" + m_CtrY +  " EndYaw=" + m_EndYaw +  " Kp=" + m_Kp + " TO=" + m_TO;
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line);
    	System.out.println("DriveArcCmd Init");
    	
    	setTimeout(m_TO);
    	zoneNum = 10;								// 7 = DriveArcTurnCmd
    	Robot.drivetrain.resetEncodersAndStats();
    	
    	
    	//if (m_leftPwr < 0) 	currLeftStopPwr = -STOP_LEFT_PWR;		// Brake Power must be opposite of drive pwr
    	//else 				currLeftStopPwr = STOP_LEFT_PWR;
    	//if (m_rightPwr < 0) currLeftStopPwr = -STOP_RIGHT_PWR;		// Brake Power must be opposite of drive pwelse r
    	//else				currLeftStopPwr = STOP_RIGHT_PWR;

    	mDriveState = DriveState.START;									// We are just starting out will need to accel.
    	mDriveDir = DriveDir.FWD;										// For now only drive forward !!!!
    	startTmr.reset();
    	startTmr.start();
    	stallCtr = 0;
    	currYaw = Robot.drivetrain.getGyroYaw();
    	
       	if (currYaw <= m_EndYaw) {
        	tgtYawDir = +1;	// clockwise turn    		
    		mTurnDir = TurnDir.RIGHT;
    	} else {
        	tgtYawDir = -1;	// clockwise turn     		
    		mTurnDir = TurnDir.LEFT;
    	}
    	
    	// Possibly remove this after done testing. Vales can be tested without recompile and download
    	double p = m_Kp;
    	double pid_P = Robot.prefs.getDouble("Talon_10_PID_P", p);  

    	SimpleArcFollower mArcFollower = new SimpleArcFollower(m_Radius, m_CtrX, m_CtrY, tgtYawDir, m_BasePwr, pid_P);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      	// ---- Get Current Position and Velocities ----
    	currX = Robot.drivetrain.getPositionX();
    	currY = Robot.drivetrain.getPositionY();
    	currZ = Robot.drivetrain.getPositionZ();
    	currDist = Robot.drivetrain.getAverageDist();
    	currYaw = Robot.drivetrain.getGyroYaw();
    	currSpeed = Robot.drivetrain.getAverageSpeed();
    	
    	// --- Calculate New Power Outputs ---
		m_FollowArcOutput = mArcFollower.getUpdate(currX, currY, currZ );
		currLeftPwr = m_FollowArcOutput.leftPwr;
		currRightPwr = m_FollowArcOutput.rightPwr;
		
		// --- Calculate remaining distance to Target ---
    	//m_RemainTgtDist = m_dist - currDist;
    	
    	m_RemainTgtYaw = m_EndYaw - currYaw;    	

    	// ----- State 0 (Initial Stop State) -----
    	if (mDriveState == DriveState.START){
    		// were are just starting, we need to move check timer for motion		
    		if(startTmr.get() > START_TIME) {
    			// we should be moving now
    			mDriveState = DriveState.DRIVING;
    		}
    	}
    	
    	// ----- Test to see if we have stopped (Brake Complete or Collision)----
    	if ((mDriveState == DriveState.DRIVING ) || ( mDriveState == DriveState.BRAKING )){
    		// ----- Check to see if we have hit something or if braking has brought the robot to a stop -----
    		if  ((mDriveDir == DriveDir.FWD) && (Robot.drivetrain.getAverageSpeed() <= STALL_VELOCITY)) {
    			// we have stopped moving we may have hit something so stop
    			stallCtr++;
    			if (stallCtr >= 3) {
    				if (mDriveState == DriveState.DRIVING) {
    					// we have hit something and we are not in brake mode
    					mDriveState = DriveState.STALLED;
    					return;
    				} else {
    					// we are in brake mode and have just come to rest
    					mDriveState = DriveState.ATEND;
    					return;
    				}
    			}
    		} else {
    			// we are moving so reset stall timer
    			stallCtr = 0;
    		}
    	}
    	  	
    	
    	if (mDriveState == DriveState.DRIVING){
    		// ---- Check to see if we have overshot are ending point
    		if (mTurnDir == TurnDir.RIGHT) {
    			if ((currX >= m_EndX) || (currY >= m_EndY)) {
    				// We have completed the requested turn yaw so it's time to end
    				mDriveState = DriveState.ATEND;
    				return;
    			}
    		} else {
    			if ((currX >= m_EndX) || (currY <= m_EndY)) {
    				// We have completed the requested turn yaw so it's time to end
    				mDriveState = DriveState.ATEND;
    				return;
    			}
    		}
    	}    	
    	
    	if (mDriveState != DriveState.STALLED){
    		// we are not done so send pwr to drivetrain    		
        	Robot.drivetrain.tankDrive(currLeftPwr, currRightPwr);
    		Robot.drivetrain.putZoneData( zoneNum, 0 , 0, tgtYaw, m_RemainTgtYaw );	// Log distance to tgt
    	}

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) return true;				// used in all modes

    	if (mDriveState == DriveState.ATEND) {
    		// Cmd has completed its distance
    		line = "DriveArcCmd - Done - has reached its target !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;   		
    		return true;
    	}

    	if (mDriveState == DriveState.STALLED) {
    		// We have stalled
    		line = "DriveArcCmd - Has STOPPED speed below " + STALL_VELOCITY + " inches per sec. !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true; 		// We have stopped so exit
    	}

        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
		line = "DriveArcnCmd has ended !!";
		Robot.logger.appendLog(line);
		System.out.println(line) ;
    	Robot.drivetrain.stopMtrs();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
