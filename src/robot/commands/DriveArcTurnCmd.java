// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;
import robot.commands.DriveFwd2Cmd.DriveDir;
import robot.commands.DriveFwd2Cmd.DriveMode;

/**
 *
 */
public class DriveArcTurnCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_leftPwr;
    private double m_rightPwr;
    private double m_dist;
    private double m_hdg;
    private int m_mode;
    private double m_TO;
    private boolean m_BrakeFlag;
    private boolean m_PIDMode;
    
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    String line;

    Timer startTmr = new Timer();
    double START_TIME = 0.08;							// Time to wait for motors to start moving robot
    int stallCtr = 0;
    final double STALL_VELOCITY = 1.0;					// Speed less than this will indicate stopped
    final double STOP_LEFT_PWR  = - 0.15;				// Power to reverse motors to brake
    final double STOP_RIGHT_PWR  = - 0.15;				// Power to reverse motors to brake
    int driveProfileFlag, stopFlag;
    double currPwr,currLeftPwr,currRightPwr, currLeftStopPwr, currRightStopPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_RemainTgtYaw, currDist, currYaw, currSpeed;
    char m_Zone;
    int zoneNum;

    public enum DriveMode { DIST, HDG };
    private DriveMode mDriveMode = DriveMode.DIST;	// this keeps track of our current drive mode
    
    public enum DriveState { START, DRIVINGDIST , DRIVINGHDG, BRAKING, STALLED, ATEND, DONE };
    private DriveState mDriveState = DriveState.START;	// this keeps track of our current drive mode
    
    public enum DriveDir { FWD, REV };
    private DriveDir mDriveDir = DriveDir.FWD;	// this keeps track of our current drive direction
    
    public enum TurnDir { RIGHT, LEFT };
    private TurnDir mTurnDir = TurnDir.RIGHT;	// this keeps track of our current turn direction
        
    

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveArcTurnCmd(double leftPwr, double rightPwr, double dist, double hdg, int mode, double TO, boolean BrakeFlag, boolean PIDMode) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_leftPwr = leftPwr;
        m_rightPwr = rightPwr;
        m_dist = dist;
        m_hdg = hdg;
        m_mode = mode;
        m_TO = TO;
        m_BrakeFlag = BrakeFlag;
        m_PIDMode = PIDMode;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        
    	// Mode 0 = Go Distance
    	// Mode 1 = Go to heading
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = "********** Starting DriveArcTurnCmd ***********";
    	line +=  " LeftPwr=" + m_leftPwr + " RtPwr=" + m_rightPwr;    	
    	line +=  " Dist=" + m_dist +  " Hdg=" + m_hdg +  " Mode=" + m_mode + " TO=" + m_TO;
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line);
    	System.out.println("DriveArcTurnCmd Init");
    	if (m_PIDMode) {
    		//  Drive by velocity PID  
    		double p = 0.34;
    		double f = 0.34;
    		double pid_P = Robot.prefs.getDouble("Talon_10_PID_P", p);
    		double pid_F = Robot.prefs.getDouble("Talon_11_PID_F", f);    	
    		Robot.drivetrain.setTalonByVel( pid_P, pid_F);
    		line = "Starting DriveFwdVelocityCmd PID Values  pid_P=" + pid_P + " pid_F=" + pid_F;    	
    		Robot.logger.appendLog(line);
    		System.out.println(line);  
    	}
    	
    	setTimeout(m_TO);
    	zoneNum = 7;								// 7 = DriveArcTurnCmd
    	Robot.drivetrain.resetEncodersAndStats();
    	
    	if (m_mode == 1) {
    		mDriveMode = DriveMode.HDG;
    	} else {
    		mDriveMode = DriveMode.DIST;	
    	}
    	
    	if (m_leftPwr < 0)  {
    		// both sides need to have same sign, we can fix this later
    		// this is used for collision detection
    		mDriveDir = DriveDir.REV;    			
    	} else {    			
    		mDriveDir = DriveDir.FWD;
    	}    	
    	
    	if (mDriveMode == DriveMode.DIST) {
        	m_RemainTgtDist = m_dist;
    		if (m_dist >= 0)  {
    			mDriveDir = DriveDir.FWD;    			
    		} else {    			
    			mDriveDir = DriveDir.REV;
    			if ( m_leftPwr > 0 ) m_leftPwr *= -1;		// Power must be negative
        		if ( m_rightPwr > 0 ) m_rightPwr *= -1;	// Power must be negative
    		}
    	}
    	
    	if (m_leftPwr < 0) 	currLeftStopPwr = -STOP_LEFT_PWR;		// Brake Power must be opposite of drive pwr
    	else 				currLeftStopPwr = STOP_LEFT_PWR;
    	if (m_rightPwr < 0) currLeftStopPwr = -STOP_RIGHT_PWR;		// Brake Power must be opposite of drive pwelse r
    	else				currLeftStopPwr = STOP_RIGHT_PWR;

    	mDriveState = DriveState.START;									// We are just starting out will need to accel.
    	startTmr.reset();
    	startTmr.start();
    	stallCtr = 0;
    	currYaw = Robot.drivetrain.getGyroYaw();    	
    	if (currYaw <= m_hdg) {
    		mTurnDir = TurnDir.RIGHT;
    	} else {
    		mTurnDir = TurnDir.LEFT;
    	}
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      	// ---- Look up key data to start ----
    	currDist = Robot.drivetrain.getAverageDist();
    	currYaw = Robot.drivetrain.getGyroYaw();
    	currSpeed = Robot.drivetrain.getAverageSpeed();
    	m_RemainTgtDist = m_dist - currDist;
    	
    	m_RemainTgtYaw = m_hdg - currYaw;    	

    	// ----- State 0 (Initial Stop State) -----
    	if (mDriveState == DriveState.START){
    		// were are just starting, we need to move check timer for motion
    		currLeftPwr = m_leftPwr;
    		currRightPwr = m_rightPwr;
    		if(startTmr.get() > START_TIME) {
    			// we should be moving now
    			if (mDriveMode == DriveMode.DIST) mDriveState = DriveState.DRIVINGDIST;
    			else							  mDriveState = DriveState.DRIVINGHDG;	
    		}
    	}

    	// ----- Test to see if we have stopped (Brake Complete or Collision)----
    	if ((mDriveState == DriveState.DRIVINGDIST ) || (mDriveState == DriveState.DRIVINGHDG ) || ( mDriveState == DriveState.BRAKING )){
    		// ----- Check to see if we have hit something or if braking has brought the robot to a stop -----
    		if  (((mDriveDir == DriveDir.FWD) && (Robot.drivetrain.getAverageSpeed() <= STALL_VELOCITY)) ||
    			 ((mDriveDir == DriveDir.REV) && (Robot.drivetrain.getAverageSpeed() >= -STALL_VELOCITY))) {
    			// we have stopped moving we may have hit something so stop
    			stallCtr++;
    			if (stallCtr >= 3) {
    				if ((mDriveState == DriveState.DRIVINGDIST) ||  (mDriveState == DriveState.DRIVINGHDG)){
    					// we have hit something and we are not in brake mode
    					mDriveState = DriveState.STALLED;
    					return;
    				} else {
    					// we are in brake mode and have just come to rest
    					mDriveState = DriveState.ATEND;
    					return;
    				}		
    			}
    		} else {
    			// we are moving so reset stall timer
    			stallCtr = 0;    			
    		}
    	}
    	
    	// ----- State 1 (Driving to End target by Distance) -----
    	if (mDriveState == DriveState.DRIVINGDIST){
    		// ----- Check to see if we have are done -----
    		if (((mDriveDir == DriveDir.FWD) && (m_RemainTgtDist <= 0)) ||
    			((mDriveDir == DriveDir.REV) && (m_RemainTgtDist >= 0))){
    			// We have hit our target distance so were done
    			if (m_BrakeFlag) {
    				// we need to brake to a stop
    				mDriveState = DriveState.BRAKING;
    				zoneNum = 9;						// 9 = Braking
    				currLeftPwr = currLeftStopPwr;
    				currRightPwr = currRightStopPwr;
    			} else {
    				// were all done just exit
    				mDriveState = DriveState.ATEND;
    				return;
    			}
    		}
    	}
    	
    	if (mDriveState == DriveState.DRIVINGHDG){
    		// ----- Check Heading to see if we have are done) -----    		
    		if ((mTurnDir == TurnDir.RIGHT) && (m_RemainTgtYaw <= 0)) {
				// We have completed the requested turn yaw so it's time to end
				mDriveState = DriveState.ATEND;     				
    		}
    		if  ((mTurnDir == TurnDir.LEFT) && (m_RemainTgtYaw >= 0)) {
				// We have completed the requested turn yaw so it's time to end
				mDriveState = DriveState.ATEND;    				
    		}
    		if (mDriveState == DriveState.ATEND) {
    			if (!m_BrakeFlag) {
    				return;	// were all done
    			}
    			else {
    				// We need to brake
    				mDriveState = DriveState.BRAKING; 
    				zoneNum = 9;						// 9 = Braking
    				currLeftPwr = currLeftStopPwr;
    				currRightPwr = currRightStopPwr;
    			}
    		}
    	}
    	
    	if (mDriveState != DriveState.STALLED){
    		// we are not done so send pwr to drivetrain    		
        	if (!m_PIDMode) {
        		Robot.drivetrain.tankDrive(m_leftPwr, m_rightPwr);
        	} else {
        		// Drive by velocity PID
        		Robot.drivetrain.driveByVel(m_leftPwr, m_rightPwr);
        	}
    		Robot.drivetrain.putZoneData( zoneNum, m_dist, m_RemainTgtDist, tgtYaw, m_RemainTgtYaw );	// Log distance to tgt
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) return true;				// used in all modes

    	if (mDriveState == DriveState.ATEND) {
    		// Cmd has completed its distance
    		line = "DriveArcTurnCmd - Done - has reached its target !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;   		
    		return true;
    	}

    	if (mDriveState == DriveState.STALLED) {
    		// We have stalled
    		line = "DriveArcTurnCmd - Has STOPPED speed below " + STALL_VELOCITY + " inches per sec. !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true; 		// We have stopped so exit
    	}
    	
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
		line = "DriveArcTurnCmd has ended !!";
		Robot.logger.appendLog(line);
		System.out.println(line) ;
    	Robot.drivetrain.stopMtrs();
    	if (m_PIDMode) Robot.drivetrain.setTalonByPercent(); 		// Reset Controllers back to normal
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
