// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import java.util.Vector;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;
import robot.subsystems.Drivetrain.DriveMode;

/**
 *
 */
public class DriveFwd2Cmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_dist;
    private double m_pwr;
    private double m_hdg;
    private double m_Mode;
    private double m_TO;
    private boolean m_BrakeFlag;
    private boolean m_LimitOverideFlag;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    String line;

    Timer startTmr = new Timer();
    int stallCtr = 0;
    final double START_TIME = 0.08;				// Time to wait for motors to start moving robot
    final double STALL_VELOCITY = 2.0;			// Speed less than this will indicate stopped 
    final double STOP_PWR  = - 0.50;			// Power to reverse motors to brake
    double currStop_pwr = STOP_PWR;
    
    int driveProfileFlag, stopFlag, zoneNum;
    double currPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_CurrTgtDist, currDist, currSpeed;
    char m_Zone;
    
    public enum DriveMode { START, DRIVING, BRAKING, STALLED, ATEND, DONE };
    private DriveMode mDriveState = DriveMode.START;	// this keeps track of our current drive mode
    
    public enum DriveDir { FWD, REV };
    private DriveDir mDriveDir = DriveDir.FWD;	// this keeps track of our drive direction

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveFwd2Cmd(double dist, double pwr, double hdg, double Mode, double TO, boolean BrakeFlag, boolean LimitOverideFlag) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_dist = dist;
        m_pwr = pwr;
        m_hdg = hdg;
        m_Mode = Mode;
        m_TO = TO;
        m_BrakeFlag = BrakeFlag;
        m_LimitOverideFlag = LimitOverideFlag;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        
    	// Mode 		0 = Go Straight to current heading
    	//      		1 = Go Straight to provided Yaw heading
    	// BrakeFlag 	0 = no braking
    	//           	1 = Brake
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = " ********** Starting DriveFwd2Cmd ***********";
    	line +=  " Dist=" +String.valueOf(m_dist) + " Pwr=" + String.valueOf(m_pwr);
    	line += " TimeOut=" + String.valueOf(m_TO) + " Hdg=" + m_hdg + " Mode=" + String.valueOf(m_Mode);
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line);
    	System.out.println("DriveFwdCmd Init");
    	setTimeout(m_TO);
    	zoneNum = 6;						// 7 = DriveArcTurn
    	Robot.drivetrain.resetEncodersAndStats();

    	if ((m_dist == 0) && (m_pwr == 0)) {
    		// Get TEst Data !
        	m_dist = Robot.prefs.getDouble	("Test_10_Fwd2Dist", m_dist);
        	m_pwr = Robot.prefs.getDouble	("Test_11_Fwd2Pwr", m_pwr);    		
    	}
    	
    	if ((m_dist < 0) && ( m_pwr > 0 )) m_pwr *= -1;// Power must be negative if Distance is negative
    	if (m_pwr < 0) 	currStop_pwr = -STOP_PWR;					// Brake Power must be opposite of drive pwr
    	else 			currStop_pwr = STOP_PWR;
    	if (m_dist < 0) mDriveDir = DriveDir.REV;
    	else 			mDriveDir = DriveDir.FWD;
    	
    	m_RemainTgtDist = m_dist;
    	
    	mDriveState = DriveMode.START;	// this keeps track of our current drive mode
    	startTmr.reset();									// We are just starting out will need to accel.
    	startTmr.start();    	
    	stallCtr = 0;

    	if (m_Mode == 0) {
     		tgtYaw = Robot.drivetrain.getGyroYaw();		// Get current yaw and use that as target
    	} else {
    		tgtYaw = m_hdg;								// Pass through provided target yaw
    	}
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      	// ---- Look up key data to start ----
    	currDist = Robot.drivetrain.getAverageDist();
    	currSpeed = Robot.drivetrain.getAverageSpeed();
    	m_RemainTgtDist = m_dist - currDist;

    	// ----- State 0 (Initial Stopped State) -----
    	if (mDriveState == DriveMode.START){
    		// were are just starting, we need to move check timer for motion
    		currPwr = m_pwr;
    		if(startTmr.get() > START_TIME) {
    			// we should be moving now
        		mDriveState = DriveMode.DRIVING;    			
    		}
    	}
    	
    	// ----- Test to see if we have stopped moving (Brake Complete or Collision)----
    	if ((mDriveState == DriveMode.DRIVING ) || ( mDriveState == DriveMode.BRAKING )){
    		// ----- Check to see if we have hit something or if braking has brought the robot to a stop -----
    		if  (((mDriveDir == DriveDir.FWD) && (Robot.drivetrain.getAverageSpeed() <= STALL_VELOCITY)) ||
    			 ((mDriveDir == DriveDir.REV) && (Robot.drivetrain.getAverageSpeed() >= -STALL_VELOCITY))) {
    			// we have stopped moving we may have hit something so stop
    			if (stallCtr >= 3) {
    				if (mDriveState == DriveMode.DRIVING) {
    					// we have hit something and we are not in brake mode
    					mDriveState = DriveMode.STALLED;
    					return;
    				} else {
    					// we are in brake mode and have just come to rest
    					mDriveState = DriveMode.ATEND;
    					return;
    				}
    			}
    			stallCtr++;
    		} else {
    			// we are moving so reset stall Ctr
    			stallCtr = 0;    			
    		}
    	}

    	// ----- State 1 (Driving to End target) -----
    	if (mDriveState == DriveMode.DRIVING){
    		// ----- Check to see if we have are done -----
    		if (((mDriveDir == DriveDir.FWD) && (m_RemainTgtDist <= 0)) ||
    			((mDriveDir == DriveDir.REV) && (m_RemainTgtDist >= 0))){
    			// We have hit our target distance so were done
    			if (m_BrakeFlag) {
    				// we need to brake to a stop
    				mDriveState = DriveMode.BRAKING;
    				zoneNum = 9;						// 9 = Braking
    				currPwr = currStop_pwr;
    			} else {
    				// we're all done just exit
    				mDriveState = DriveMode.ATEND;
    				return;
    			}
    		}
    	}
		
    	if (mDriveState != DriveMode.ATEND){
    		// we are not done so continue sending pwr to drivetrain
        	Robot.drivetrain.driveStraightToHdg(currPwr, tgtYaw, m_LimitOverideFlag);
        	Robot.drivetrain.putZoneData( zoneNum, m_dist, m_RemainTgtDist, tgtYaw, 0 );	// Log distance to tgt 
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) {
    		// Cmd has timed out
    		line = "DriveFwd2Cmd - Has TIMED OUT !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ; 
    		return true;				// used in all modes
    	}

    	if (mDriveState == DriveMode.ATEND) {
    		// Cmd has completed its distance
    		line = "DriveFwd2Cmd - Done - has reached its target !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;   		
    		return true;
    	}

    	if (mDriveState == DriveMode.STALLED) {
    		// We have stalled/Stopped so exit
    		line = "DriveFwd2Cmd - Has STOPPED speed below " + STALL_VELOCITY + " inches per sec. !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true; 		// We have stopped so exit
    	}
 
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
		line = "DriveFwd2Cmd has ended !!";
		Robot.logger.appendLog(line);
		System.out.println(line) ;
    	Robot.drivetrain.stopMtrs();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
