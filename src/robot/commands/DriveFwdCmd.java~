// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import java.util.Vector;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

/**
 *
 */
public class DriveFwdCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_tgtDist;
    private double m_accelPwr;
    private double m_cruisePwr;
    private double m_decelPwr;
    private double m_slowPwr;
    private double m_stopPwr;
    private double m_accelDist;
    private double m_decelDist;
    private double m_slowSpeed;
    private double m_stopDist;
    private double m_TO;
    private int m_Mode;
    private double m_hdg;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    String line;

    Timer stallTmr = new Timer();
    Timer stopTmr = new Timer();
    double STALL_VELOCITY = 1.0;			// Speed less than this will indicate stopped 
    
    int driveModeFlag, driveProfileFlag, stopFlag;
    double currPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_CurrTgtDist, currDist, currSpeed;
    char m_Zone;
    boolean weHadMotionFlag;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveFwdCmd(double tgtDist, double accelPwr, double cruisePwr, double decelPwr, double slowPwr, double stopPwr, double accelDist, double decelDist, double slowSpeed, double stopDist, Double TO, int Mode, double hdg) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_tgtDist = tgtDist;
        m_accelPwr = accelPwr;
        m_cruisePwr = cruisePwr;
        m_decelPwr = decelPwr;
        m_slowPwr = slowPwr;
        m_stopPwr = stopPwr;
        m_accelDist = accelDist;
        m_decelDist = decelDist;
        m_slowSpeed = slowSpeed;
        m_stopDist = stopDist;
        m_TO = TO;
        m_Mode = Mode;
        m_hdg = hdg;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = "Debug, Drivetrain, ********** Starting DriveFwdCmd ***********";
    	line += " Speed=" + String.valueOf(m_cruisePwr) + " Dist=" +String.valueOf(m_tgtDist);
    	line += " TimeOut=" + String.valueOf(m_TO) + " Hdg=" + String.valueOf(m_Mode);
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line);
    	System.out.println("DriveFwdCmd Init");
    	setTimeout(m_TO);

    	Robot.drivetrain.resetEncodersAndStats();
    	if (m_tgtDist < 0) m_tgtDist = m_tgtDist * -1;	// Distance is positive, speed can be neg. ??
    	m_RemainTgtDist = m_tgtDist;
    	weHadMotionFlag = false;						// false=NO motion yet, true=Motion has begun
    	stopFlag = 0;									// Clear stop flag to start
    	driveModeFlag = 0;								// We are just starting out will need to accel.

    	// Mode 0 = Go Straight to current heading
    	// Mode 1 = Go Straight to provided Yaw heading 
    	//  		Yaw =  +-180degrees (+ turn right of straight) , ( -  turn left of straight)
    	if (m_Mode == 0) {
     		tgtYaw = Robot.drivetrain.getGyroYaw();		// Get current yaw and use that as target
    	} else {
    		tgtYaw = m_hdg;								// Pass through provided target yaw
    	}
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
       	// ---- Look up key data to start ----
    	currDist = Robot.drivetrain.getAverageDist();
    	currSpeed = Robot.drivetrain.getAverageSpeed();
    	m_RemainTgtDist = m_tgtDist - currDist;

    	// ----- State 0 (Initial Stop State) -----
    	if (driveModeFlag == 0){
    		// were starting to accelerate
    		driveModeFlag = 1;
    		Robot.logger.appendLog("We are starting to acelerate up to speed   (autoDriveFwdCmd) !");
    		currPwr = m_accelPwr;
    	}

    	// ----- State 1 (Accel State) we are accelerating at begining -----
    	if (driveModeFlag == 1){
    		if (currSpeed > 0) weHadMotionFlag = true;	// ww are moving so set flag indicating so
    		// Have we reached the point to change to cruise state
    		if (currDist > m_accelDist){
    			Robot.logger.appendLog("We have reached speed starting to cruise  (autoDriveFwdCmd) !");
    			driveModeFlag = 2;
    			currPwr =  m_cruisePwr; }
    	}

    	// ----- State 2 (Cruise State) We are cruising down the road now -----
    	if (driveModeFlag == 2){
    		// Have we reached the point we need to decelerate to slow speed?
			if ((m_Mode == 0) || (m_Mode == 1)) {    		
				// These modes (0 and 1) require braking so begin the sequence as needed,
				// otherwise ignore braking and keep cruising.
				// when target distance is reached the command will exit, and next command takes over
				if (m_RemainTgtDist <= m_decelDist){
    				Robot.logger.appendLog("We are starting to Decelerate to Slow speed   (autoDriveFwdCmd) !");
    				driveModeFlag = 3;
    				currPwr =  m_decelPwr; }
    		}
    	}

    	// ----- State 3 (Decel State) We are decelerating down to the slow speed before braking -----
    	if (driveModeFlag == 3){
    		// Have we reached decelerated to the slow Speed (10 inches per sec.)
    		if (currSpeed <= 10){
    			Robot.logger.appendLog("We have reached Slow speed   (autoDriveFwdCmd) !");
    			driveModeFlag = 4;
    			currPwr =  m_slowPwr; }
    	}

    	// ----- State 4 (Slow speed State) -----
    	if (driveModeFlag == 4){
    		// Have we reached the point we need to start braking to a stop
    		if (m_RemainTgtDist <= m_stopDist){
    			Robot.logger.appendLog("We have rached Brake point starting to brake  (autoDriveFwdCmd) !");
    			driveModeFlag = 5;
    			currPwr =  m_stopPwr; }
    	}

    	// ----- Check to see if we have gone too far and State 5 (Brake State) -----
    	if (m_RemainTgtDist <= 0){
    		if ((m_Mode == 2) || (m_Mode ==3)){
    			// In these 2 modes (2 and 3) we don't want to apply brakes even though we are at the end
    			// We just set mode to 6 to exit this command, so the next command can continue motion
    			driveModeFlag = 6;
    			return;
    		}
    		if (stopFlag == 0){
    			System.out.println("  We may have over run target DISTANCE");
    			Robot.logger.appendLog("We have over run target need to Brake   (autoDriveFwdCmd) !");
    		}
    		driveModeFlag = 5;		// we need to brake
    	}

    	// ----- State 5 (Brake State) -----
    	if (driveModeFlag == 5) {
    		stopFlag = 1;
    		if (Robot.drivetrain.getAverageSpeed() > 0){
    			// we are still moving forward continue braking
    			currPwr = -0.2;
    		}
    		else {
    			// we have finally stopped so were all done
    			driveModeFlag = 6;
    			System.out.println("We have stopped");
    			Robot.logger.appendLog("We were braking and have now stopped  (autoDriveFwdCmd) !");
    		}
    	}

    	if (driveModeFlag != 5){
    		// we are not in brake mode so send pwr to drivetrain
    		SendPwrToDrivetrain( currPwr );
    	}
    	return;

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) return true;				// used in all modes

    	if (driveModeFlag == 6) return true; 		// We have stopped so exit

    	if ( (currSpeed <= 0) && (weHadMotionFlag == true )){
    		// Make sure we are past the slow start, end when stopped
    		Robot.logger.appendLog("We have stopped   (autoDriveFwdCmd) !");
    		System.out.println("We have stopped");
    		return true;		// we have stopped so end
    	}
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	Robot.drivetrain.stopMtrs();							// stop the motors
    	Robot.drivetrain.putZoneData( 0, 0, 0, 0, 0);					// Stop logging distance to tgt
    	Robot.logger.appendLog("**** Ending AutoFwdCmd *****");
    	System.out.println("AutoFwdCmd End");
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
      	end();
    }
    
    // ------------------------------------------------------------
    void SendPwrToDrivetrain(double speed){
    	double yawRemain = tgtYaw - Robot.drivetrain.getGyroYaw();
    	Robot.drivetrain.putZoneData( 1, m_tgtDist, m_RemainTgtDist, tgtYaw, yawRemain );	// Log distance to tgt    	
    	Robot.drivetrain.driveStraightToHdg(speed, tgtYaw, false);
    } 
}
