// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;
import robot.subsystems.Drivetrain.DrivePIDStatus;


/**
 *
 */
public class DriveFwdPidCmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_Distance;
    private int m_Mode;
    private double m_TO;
    private double m_Hdg;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    private String line;
    double tgtYaw;
    Timer driveTmr;
    boolean firstTimeFlag;
    double ENDTIME = 0.25;			// Time since hitting the end to shutdown routine
    int state = 0;					//   0=init, 1=moving, 2=Stopped Moving, 3=PID Stopped 4=ATEND
    int startCnt, stopCnt;	// Counter for how long we have been stoped or moving
	double currDist, lastDist;
	double STOPSPEED = 2.0;			// Anything slower than this looks like a stop
	double STARTSPEED = 4.0 ;		// Anything faster than this looks like a start
	
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveFwdPidCmd(double Distance, int Mode, double TO, double Hdg) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_Distance = Distance;
        m_Mode = Mode;
        m_TO = TO;
        m_Hdg = Hdg;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = "Drive Straight PID Command Init! (Dist=" + m_Distance + " Mode=" + m_Mode + "  TO=" + m_TO +" Hdg=" + m_Hdg;
    	System.out.println(line) ;
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line) ;
    	setTimeout(m_TO);
    	state = 0;								// Initial startup state
    	stopCnt = 0;
    	startCnt = 0;
    	double currYaw;

    	// Mode 0 = Go Straight to current heading
    	// Mode 1 = Go Straight to provided Yaw heading 
    	//  		( Yaw =  +-180degrees (+ turn right of straight) , ( -  turn left of straight) )
    	currYaw =  Robot.drivetrain.getGyroYaw();
    	if (m_Mode == 0) {
     		tgtYaw = currYaw;		// Get current yaw and use that as target
    	} else {
    		tgtYaw = m_Hdg;								// Pass through provided target yaw
    	}
		Robot.drivetrain.driveStraightPid(m_Distance, tgtYaw) ;
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	if (state == 0) {
    		// Look to see if we have started moving yet (speed > xxx could use currDist > xxx)
    		if (Math.abs(Robot.drivetrain.getAverageSpeed()) > STARTSPEED ) {
    			// Speed is now greater that +-4 inches per second
    			startCnt ++;
    			if (startCnt > 3) state = 1; 	// we may be moving give it 80 ms to be sure 
    		} else {
    			startCnt = 0;					// reset counter must have been a fluke
    		}
    	}
    	
    	if (state == 1) {
    		// look to see if we have hit something or have stopped moving
    		if (Math.abs(Robot.drivetrain.getAverageSpeed()) < STOPSPEED) {
    			stopCnt ++;
    			if (stopCnt > 2) {
    				state = 2;		// we have stopped
    			}
    		} else {
    			stopCnt = 0;					// reset counter must have been a fluke
    		}
    	   	if (Robot.drivetrain.getDrivePIDStatus() == DrivePIDStatus.STOPPED) {
    	   		state = 3;
    	   	}
    		
    	  	if (Robot.drivetrain.getDrivePIDStatus() == DrivePIDStatus.ATEND) {
    		    // PID has indicated its at the end but hasnt stopped
    	  		// consider a Timer to give time for final corection and then end ie) after 0.25 seconds end run
        		line = "DriveFwdPIDCmd - detected PIDStatus is ATEND";
        		Robot.logger.appendLog(line);
        		System.out.println(line) ;  
    	  		//state = 4;
    	  	}
    	}
    }

    
    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) {
    		line = "DriveFwdPIDCmd - Has timed out !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true;								// used in all modes
    	}
    	
    	if (state == 2) {
    		// We have stopped moving time to end
    		line = "DriveFwdPIDCmd - Done - Command has detected Robot has stopped moving !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true;
    	}

    	if (state == 3) {
    		// PID has indicated its complete
    		line = "DriveFwdPIDCmd - Done - Pid has indicated it is STOPPED !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true;
    	}
	
   		// consider testing for termination conditions such as
   		// 1. Timer - when distance is within tolerance start timer and after 0.25 seconds end run
   		// 2. Look at velocity when in tolerance zone if less than ~5 inches per sec. end run
   		// 3. Look at velocity even if not in tol-zone if it has dropped below a certain threshold then were done (assumming we had been moving)
    	
    	return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
		line = "DriveFwdPIDCmd has ended !!";
		Robot.logger.appendLog(line);
		System.out.println(line) ;
    	Robot.drivetrain.stopPID();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
