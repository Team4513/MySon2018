// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.subsystems;

import robot.Robot;
import robot.RobotMap;
import robot.commands.*;
import robot.commands.DriveFwd2Cmd.DriveDir;
import robot.subsystems.Drivetrain.DriveMode;
import robot.subsystems.Drivetrain.DrivePIDStatus;
import robot.utils.Rmath;
import robot.utils.SuperPid;
import robot.utils.SuperPid.PidStatus;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class ArmSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX armMtrCtlr = RobotMap.armSubSysArmMtrCtlr;
    private final AnalogPotentiometer armPotentiometer = RobotMap.armSubSysarmPotentiometer;
    private final DigitalInput armLwrLmtSw = RobotMap.armSubSysarmLwrLmtSw;
    private final DigitalInput armUpperLmtSw = RobotMap.armSubSysArmUpperLmtSw;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    //------------Constants-------------
    // --- default values ---
    static private final double TOPANGLE = 170;					// Angle when full raise
    static private final double BOTANGLE = 30;					// Angle when fully lowered   
    static private double ANGLERANGE = TOPANGLE -  BOTANGLE;    
    static private final double kTopVoltDefault = 0.95;			// Voltage at top
    static private final double kBotVoltDefault = 3.69;			// Voltage at bottom
    static private double kVoltDiffDefault = kBotVoltDefault - kTopVoltDefault;
    
	static final private boolean KLIMIT_SWITCH_PRESSED = true;
	static final private boolean KLIMIT_SWITCH_NOT_PRESSED = false;
	
	public static final double KRaiseSpeedDefault =  +1.0; 
	public static final double KLowerSpeedDefault = -.40;
	public static final double KHoldSpeedDefault  = +0.013;
	public static double KRaiseSpeed, KLowerSpeed, KHoldSpeed;
	
	public static final double KLimitArmTopSlow1Pos= 150;
	public static final double KLimitArmTopSlow2Pos= 160;	
	public static final double KLimitArmBotSlow1Pos= 40;
	public static final double KLimitArmBotSlow2Pos= 40;

	public static final double KLimitArmTopSlow1MaxPwr= 0.2;
	public static final double KLimitArmTopSlow2MaxPwr= 0.1;	
	public static final double KLimitArmBotSlow1MaxPwr= +0.2;
	public static final double KLimitArmBotSlow2MaxPwr= +0.1;
	
	
	public static final double KRaiseSlowSpeed= 0.1;
	public static final double KLowerSlowSpeed= +0.2;

	
    static private double kTopVolt, kBotVolt, kVoltDiff;    
    static private double ARM_POT_CONV = kVoltDiffDefault / ANGLERANGE; //Volts/degree
    
    public enum DriveDir { UP, DOWN, HOLD, STOPPED };
    private DriveDir mDriveDir = DriveDir.UP;	// this keeps track of our drive direction

    public enum LimitHitFlag { ONLIMIT, OFFLIMIT };
    private LimitHitFlag mLimitHitFlag = LimitHitFlag.ONLIMIT;	// this keeps track of recalibration
    
    // --------- PID Control Elements ----------------
    
	private static double kTgt_AngleDefault = 0 ;
	private static double kPDefault = 0 ;
	private static double kIDefault = 0 ;
	private static double kDDefault = 0 ;
	private static double kFDefault = 0 ;
	private static double kMaxOutDefault = 0 ;
	private static double kAbs_Tol_Default = 0 ;
	private static double kMoveRtDefault = 0;
	private static double kBBang_UpperDefault = 0 ;
	private static double kBBang_LowerDefault = 0 ; 
	
    static public double K_TGT_ANGLE = 0;			// Arm Target Distance
    static public double KP = 0.049;			// Arm P constant
    static public double KI = 0.0;				// Arm P constant	
    static public double KD = 0.29;				// Arm P constant
    static public double KF = 0.0;				// Arm P constant
    static public double KMAXOUT = 1.0;			// Arm Max Output
    static public double ABS_TOL = 1.0;			// Arm Tolerence for Ending
    static public double KMOVERT = 3.6;			// Arm Move Rate
    static public double KBBANG_UPPER = 0.4;	
    static public double KBBANG_LOWER = 0.01; 
	
	double kTgt_Angle, kP, kI, kD, kF, kMaxOut, kAbs_Tol, kMoveRt, kBBang_Upper, kBBang_Lower; 

	private SuperPid mSuperPid = null ;
	private double mPID_I;
	private double mPID_R;
	private double mPID_O;
    private double mPID_S; 
    
 	public enum ArmPIDMode {NULL, TELE, TOP, BOTTOM, SWITCH, SCALE, START, MOVING, HOLDING, RUNNING,  STOPPED};
    private ArmPIDMode mArmPIDMode = ArmPIDMode.START ;  	// this keeps track of our current drive mode
    
    public enum ArmPIDStatus {INIT, RUNNING, DONE, STOPPED, ATEND };
    private ArmPIDStatus mArmPIDStatus = ArmPIDStatus.INIT;

    // --------- Various Constant and Variables ----------------
 	private double mCurrArmPos = 0;						// to be displayed on smartdash
 	private double mDistRemaining = 0;					// Distance remaining to target position
 	private double mCurrArmPwr = 0;						// to be displayed on smartdash
 	private double mCurrArmVolt = 0 ;					// Voltage of Pot
 	private double mLastPos = 0 ;						// Remember last pos. to reduce redundant log prts
 	private int mPrintFlag = 0;							// log voltages once each time lmt sw is hit

	private String line;

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new armByJoystickCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
		double currPos = getArmPos();
		if 		(currPos > 150)	KHoldSpeed =  0.12;		// 0.055  The value at west valley too low!!
		else if (currPos > 120)	KHoldSpeed =  0.13; 
		else if (currPos > 100)	KHoldSpeed =  0.13;
		else if (currPos > 60)	KHoldSpeed =  0.17;
		else  					KHoldSpeed =  0.12; 
    	updateSmartDash();					// Update Arm Position Data and limit switches states
    }

    // -- basic constructor
    public ArmSubSys() {
    	mPID_I = 0;
    	mPID_R = 0;
    	mPID_O = 0;
        mPID_S = 0;
        getArmPrefs();
    }
    
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    // --------------------------------------------
    // --------- Basic Motor Commands -------------
    // --------------------------------------------
    
    //Control Motor Commands
    public void armStopMtr(){
   		mDriveDir = DriveDir.STOPPED;	// were going up
        mCurrArmPwr = 0;
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;   	
    }
    public void armHoldMtr(){
    	if (isLowerLmtSwPressed() == true) {
       		mDriveDir = DriveDir.STOPPED;
    		mCurrArmPwr = 0;
    	} else {
    		mCurrArmPwr = KHoldSpeed ;
       		mDriveDir = DriveDir.HOLD;
    	}
    	armMtrCtlr.set(-KHoldSpeed);
	   	updateSmartDash() ;
    }
    public void armMoveMtr(double speed, boolean overrideLimit){
    	if (speed > KHoldSpeed) 	mDriveDir = DriveDir.UP;	// were going up
    	else			    		mDriveDir = DriveDir.DOWN;	// were holding or going down
    	
    	if (mLimitHitFlag == mLimitHitFlag.OFFLIMIT) {
    		if  ((isUpperLmtSwPressed()) || (isLowerLmtSwPressed()))  {
        		// we have just hit a limit switch for the first time
    			recalibrateVoltages();
    			mLimitHitFlag = mLimitHitFlag.ONLIMIT; 
    		}
    	}
    	
    	if ((mPrintFlag == 1) &&  (isUpperLmtSwNotPressed()) && (isLowerLmtSwNotPressed()))
    		mPrintFlag = 0;	// we have moved off the limit switch
    	
    	    		
    	if ((mDriveDir == DriveDir.UP) && (isUpperLmtSwPressed())) {
			 armHoldMtr();
			 mDriveDir = DriveDir.HOLD;   
			 return;
    	}
    	
    	if ((mDriveDir == DriveDir.DOWN) && (isLowerLmtSwPressed())){
			mDriveDir = DriveDir.STOPPED;   
    		armStopMtr();
    		return;
    	}
		mCurrArmPwr = speed;


		mLimitHitFlag = mLimitHitFlag.OFFLIMIT; // We are not on limit 
		//This is to slow as we reach top/bottom

		if (overrideLimit == false) mCurrArmPwr = armLimitSpeed(mCurrArmPwr);    	
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;
    }
    
    public void armLower() {
    	mDriveDir = DriveDir.DOWN;	// were going down   
    	mCurrArmPwr = KLowerSpeed;

    	if ((mLimitHitFlag == mLimitHitFlag.OFFLIMIT) && (isLowerLmtSwPressed())) {
    		// we have just hit a limit switch for the first time
    		recalibrateVoltages();
    		mLimitHitFlag = mLimitHitFlag.ONLIMIT; 
    	}
    	
    	if (isLowerLmtSwPressed()){
    		mDriveDir = DriveDir.STOPPED; 	
    		armStopMtr();
    		return;
    	}
    	mLimitHitFlag = mLimitHitFlag.OFFLIMIT; 
    	mCurrArmPwr = armLimitSpeed(mCurrArmPwr);		//This is to slow when we reach bottom
		armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;    	
    }
    
    public void armRaise() {
    	mDriveDir = DriveDir.UP;	// were holding or going down   
    	mCurrArmPwr = KRaiseSpeed;
    	if ((mLimitHitFlag == mLimitHitFlag.OFFLIMIT) && (isUpperLmtSwPressed())) {
    		// we have just hit a limit switch for the first time
    		recalibrateVoltages();
    		mLimitHitFlag = mLimitHitFlag.ONLIMIT; 
    	}
    	
    	if (isUpperLmtSwPressed()) {
    		mDriveDir = DriveDir.HOLD;  
			 armHoldMtr();
			 return;
    	}
    	mLimitHitFlag = mLimitHitFlag.OFFLIMIT; 
    	mCurrArmPwr = armLimitSpeed(mCurrArmPwr);		//This is to slow when we reach top
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;    	
    }
    
    
    
    
    public double armLimitSpeed(double speed) {
    	double currPos = getArmPos();
    	double origSpeed = speed;

		// overideFlag is to allow arm move with no restrictions. This is useful when recalibrating 
    	// Upper limit switch pot position. When calibration is fouled up (such as bumping upper limit
    	// switch when arm not up), there is not enough power to raise all the way up and recalibrate.
    	int overrideFlag;
    	overrideFlag = Robot.oi.coPilotJoystick.getPOV(0);	// top of POV switch
    	if (overrideFlag == 0) return speed;
    	
    	if (mDriveDir == DriveDir.UP) {
    		if 		((currPos <= 120) && (speed > 0.85)) 	speed = 0.85;	//.85
    		else if	((currPos <= 150) && (speed > 0.75)) 	speed = 0.75;   //.75	
    		else if ((currPos <= 160) && (speed > 0.35)) 	speed = 0.35;	//.35
    		else if ((currPos <= 165) && (speed > 0.23)) 	speed = 0.23;   //.12 		
    		else if ((currPos <= 168) && (speed > 0.22)) 	speed = 0.22;	//.10
    		else if 					 (speed > 0.21)		speed = 0.21;	//.08
    	}
    	
    	if (mDriveDir == DriveDir.DOWN) {
    		if 		((currPos > 160) && (speed < -0.20))	speed =  -0.20;	// Stop the fast lurch at top
    		else if ((currPos > 150) && (speed < -0.30))	speed =  -0.30;    		
    		else if ((currPos > 145) && (speed < -0.40))	speed =  -0.40;
    		else if ((currPos > 90) &&  (speed < -0.35)) 	speed =  -0.35;
    		else if ((currPos > 60) &&  (speed < -0.25))	speed =  -0.25;
    		else if ((currPos > 50) &&  (speed < -0.15))	speed =  -0.15;
    		else if ((currPos > 35) &&  (speed < 0.0))	 	speed =  0.0;
    		//else if ((currPos > 33) &&  (speed < 0.013))	speed =  0.013;
    		else if ((currPos > 32) &&  (speed < 0.01))		speed =  0.01;
    		else if ((currPos > 31) &&  (speed < 0.035))	speed =  0.035;    		
    		else if 					(speed < 0.06)		speed =  0.06; 
    	}
    	//System.out.println(" CurrPos=" + currPos + "Orig Speed = " + origSpeed + "  New Speed=" + speed);
    	return speed;
    	
    }
   
      
    // -------------------------------------
    // ---------  Get Sensor  Data ---------
    // -------------------------------------
    public boolean isUpperLmtSwPressed() {
 	   if (armUpperLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isUpperLmtSwNotPressed() {
 	   if (armUpperLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwPressed() {
 	   if (armLwrLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwNotPressed() {
 	   if (armLwrLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
     
    public double getPot(){
    	mCurrArmVolt = armPotentiometer.get() ;
   	 	return mCurrArmVolt;
   } 
    public double getArmPos(){
    	double currPot =  getPot();
    	mCurrArmPos = (( kBotVolt - currPot) / ARM_POT_CONV) + BOTANGLE;
    	mCurrArmPos = Rmath.mRound(mCurrArmPos , 1);		// Round to 1 decimal digits
    	return mCurrArmPos;
    }
    
    public void recalibrateVoltages(){
    	// Self calibration method. Each time we hit the limit switch re-calibrate voltages
    	if (isUpperLmtSwPressed() ) {
    		kTopVolt = getPot();
    		line = "Arm Upper Limit Switch hit - ";
    	}
    	if (isLowerLmtSwPressed() ) {
    		kBotVolt = getPot() ;
    		line = "Arm Lower Limit Switch hit - ";
    	}
		kVoltDiff = kBotVolt - kTopVolt;
    	ARM_POT_CONV = kVoltDiff / ANGLERANGE; //Volts/degree
    	printCalibrations();
    }
    
    public void printCalibrations() {
    	if (mPrintFlag == 0) {
    		mPrintFlag = 1; 		// lets not keep reprinting same values
    	}
    	double pos = getArmPos();
    	line += (" kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt +
                " VOLT DIFF =" + kVoltDiff + " ArmPos=" + pos);
		//Robot.logger.appendLog(line);
		//System.out.println(line);    	
    }
    
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -----------------------
    public void getArmPrefs() {
        // grab the relevant coefficients from preferences
    	kTgt_Angle =	Robot.prefs.getDouble("Arm_10_PID_Tgt", kTgt_AngleDefault) ;
    	kP	= 	Robot.prefs.getDouble		("Arm_20_PID_P", kPDefault) ;
    	kI	= 	Robot.prefs.getDouble		("Arm_21_PID_I", kIDefault) ;
    	kD = 	Robot.prefs.getDouble		("Arm_22_PID_D", kDDefault) ;
    	kF = 	Robot.prefs.getDouble		("Arm_23_PID_F", kFDefault) ;
    	
    	kAbs_Tol = Robot.prefs.getDouble	("Arm_30_PID_Tol_In", kAbs_Tol_Default);    	
    	kMoveRt = Robot.prefs.getDouble		("Arm_31_PID_MoveRt",kMoveRtDefault);        
    	kBBang_Lower = Robot.prefs.getDouble("Arm_32_BB_Lwr",kBBang_LowerDefault);
    	kBBang_Upper = Robot.prefs.getDouble("Arm_33_PID_BB_Upr",kBBang_UpperDefault);
    	kMaxOut = Robot.prefs.getDouble		("Arm_34_PID_MaxOut", kMaxOutDefault);  

    	// Init Potentiometer voltage points upon startup
    	kTopVolt = Robot.prefs.getDouble	("Arm_40_Volt_Upper", kTopVoltDefault) ;
    	kBotVolt = Robot.prefs.getDouble	("Arm_41_Volt_Lower", kBotVoltDefault) ;
    	if (isUpperLmtSwPressed()) {
    		kTopVolt =  getPot() ;					// If Robot Arm starts at Top calibrate at this time
    	} else if (isLowerLmtSwPressed()) {
    		kBotVolt =  getPot() ;					// If Robot Arm starts at ottom calibrate at this time	
    	}
    	kVoltDiff =  kBotVolt - kTopVolt;	    	
		ARM_POT_CONV = kVoltDiff / ANGLERANGE; //Volts per inch
		
    	mLastPos = getArmPos();
    	line = (" Arm Init kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt + 
                " ANGLERANGE=" + ANGLERANGE + " ArmPos=" + mLastPos);
    	Robot.logger.appendLog(line);
    	System.out.println(line);
    	
    	KRaiseSpeed  = Robot.prefs.getDouble	("Arm_50_Raise_Pwr", KRaiseSpeedDefault) ;
    	KLowerSpeed = Robot.prefs.getDouble		("Arm_51_Lower_Pwr", KLowerSpeedDefault) ;
    	//KHoldSpeed = Robot.prefs.getDouble		("Arm_52_Hold_Pwr", KHoldSpeedDefault) ;
    	KRaiseSpeed = KRaiseSpeedDefault ;
    	KLowerSpeed = KLowerSpeedDefault ;
    	KHoldSpeed = KHoldSpeedDefault;   	
    }

   // ***********************************************************************
   // 							PID Routines
   // ***********************************************************************

   // a Command can call this to drive elevator to position (Inches)
   public void driveArmByPID(double position) {
	   mArmPIDMode = ArmPIDMode.MOVING;						// record that we're in PID mode
	   getArmPrefs();										// Get all Constants from preferences
	   kTgt_Angle = position;								// overwrite smartdashboard position
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new ArmPid(kTgt_Angle, kP, kI, kD, kF);	// create PID / default values
       Robot.logger.appendLog("**** ARM Pid Stopping *** ");
       logStartData();       
       mSuperPid.start();       							// start the PID IO (and the PID)
 	}

   // a Command can call this to drive elevator to position (Inches)
   public void driveArmByPIDTest() {
	   System.out.println("Entering driveArmByPIDTest");
	   mArmPIDMode = ArmPIDMode.MOVING;						// record that we're in PID mode
	   getArmPrefs();										// Get all Constants from preferences
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new ArmPid(kTgt_Angle, kP, kI, kD, kF);	// create PID / default values
       Robot.logger.appendLog("**** ARM Pid Stopping *** ");
       logStartData();
	   mSuperPid.start();       							// start the PID IO (and the PID)
 	}
   
   // a Command can call this to see if we're done
   public ArmPIDMode getArmPIDMode() {   
	   return mArmPIDMode ;   
   }
    
   // a Command can call this to force a stop (e.g., from a watchdog timer)    
	public void stopPID() {
		// stop the drive motors and shutdown automation
		//System.out.println("****** STOPPING AUTOMATION *****") ;
	    Robot.logger.appendLog("**** ARM Pid Stopping *** ");
		if (mSuperPid !=null) {
			mSuperPid.stop();
			// Don't delete superPid object because it can leave PID controller unreachable to disable !!!		
		 	//mSuperPid  = null ;			
		}
		mArmPIDMode = ArmPIDMode.TELE ;
		armStopMtr();
	}
   
	// --------------------------------------------------------------------------------
	// Input and Output for Elevator PID controller
	// --------------------------------------------------------------------------------
	private class ArmPid extends SuperPid 
	{
       // constructor - Set Options for SuperPid here !!!
       public ArmPid(double kDIST, double KP, double KI, double KD, double KF) {
           super(kDIST, KP, KI, KD, KF);
           mOptions.setTolerance(kAbs_Tol);								// Set Tolerance
           mOptions.setKeepRunningCriteria(false, kAbs_Tol) ;			// Set to stop at setpoint
           mOptions.setRamping(false, 0);							// Do Not use ramping
       }

       @Override
       public void applyPidOutput(double output) {
    	   mCurrArmPwr = output;
    	   armMoveMtr(output, false);
           logData();
       }

       @Override
       public double getPidInput() {
           // these are in inches
           return getArmPos();
       }
       
       @Override
       public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut,  double setpoint) {
           if (status == PidStatus.RUNNING) {
               mArmPIDStatus = ArmPIDStatus.RUNNING;
               mPID_I = input ;
               mPID_R = rawOutput ;
               mPID_O = pidOut ;
               mPID_S = setpoint ;
           } else if (status == PidStatus.STOPPED) {
               mArmPIDStatus = ArmPIDStatus.STOPPED;
               armStopMtr();	// The pid never sends a stop .. so motor continues running
               return;
           } else if (status == PidStatus.ATEND) {
               mArmPIDStatus = ArmPIDStatus.ATEND;            	
               return;
           }
       }
	}

	
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -------------------


	// ------------------- SmartDash board Methods ------------------------------------------
	public void updateSmartDash() {
     	if( isLowerLmtSwPressed())
        	SmartDashboard.putString("Arm LowerLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("Arm LowerLmtSw", "NOT Pressed") ;
     	
     	if( isUpperLmtSwPressed())
        	SmartDashboard.putString("Arm UpperLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("Arm UpperLmtSw", "NOT Pressed") ;
     	
     	SmartDashboard.putNumber("Arm CurrPos", Rmath.mRound(getArmPos() , 2)) ;
     	SmartDashboard.putNumber("Arm CurrVolt", Rmath.mRound(getPot() , 3)) ;     	
     	SmartDashboard.putNumber("Arm CurrPwr", mCurrArmPwr) ;
	}
	
	public void logData() {
		line =  "Debug - ARM PID,";
    	line += " Tgt=," + kTgt_Angle;
    	line += " , Remaing Dist=," + (kTgt_Angle - mCurrArmPos);
    	line += " , CurrPos=," + Rmath.mRound(mCurrArmPos,2);
    	line += " , CurrVolt=," + Rmath.mRound(mCurrArmVolt,3);    	
    	line += " , PidOut=," + mCurrArmPwr;    	
    	line += " , LmtSw UL=,";
    	if (isUpperLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	if (isLowerLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}
	
	public void logStartData() {
		line =  "Debug - ARM PID STARTING,";
    	line += " Tgt=," + kTgt_Angle;		
    	line += " P=," + kP;
    	line += " I=," + kI;
    	line += " D=," + kD;
    	line += " F=," + kF;
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}	
    
}

