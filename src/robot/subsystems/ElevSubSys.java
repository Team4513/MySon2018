// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.subsystems;

import robot.Robot;
import robot.RobotMap;
import robot.commands.*;
import robot.subsystems.ArmSubSys.DriveDir;
import robot.utils.Rmath;
import robot.utils.SuperPid;
import robot.utils.SuperPid.PidStatus;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class ElevSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX elevMtrCtlr = RobotMap.elevSubSysElevMtrCtlr;
    private final AnalogPotentiometer elevPotentiometer = RobotMap.elevSubSysElevPotentiometer;
    private final DigitalInput elevLwrLmtSw = RobotMap.elevSubSysElevLwrLmtSw;
    private final DigitalInput elevUpperLmtSw = RobotMap.elevSubSysElevUpperLmtSw;
    private final SpeedController elevBrakeCtlr = RobotMap.elevSubSysElevBrakeCtlr;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    //------------Constants-------------
    // --- default values ---
    
    static private double kTopVoltDefault = 0.441;			//Voltage at top    //THESE DON'T UPDATE IN CODE
    static private double kBotVoltDefault = 3.935;			//Voltage at bottom
    static private double kTopVolt, kBotVolt, kVoltDiff ;

    static final private double ELEV_TOTAL_DIST = 39.125;	//Distance in inches covered by Pot.
    static private double kVoltRange= kBotVoltDefault - kTopVoltDefault;
    static private double ELEV_POT_CONV = (kVoltRange / ELEV_TOTAL_DIST); //Volts per inch

    static final private boolean KLIMIT_SWITCH_PRESSED = true;
    static final private boolean KLIMIT_SWITCH_NOT_PRESSED = false;
    	
    // Setup these constants as preferences in Roborio so we don't need to delineate  between
    // practice and competition robots
    
    public static final double KRaiseSpeedDefault =  +1.0;		// 
    public static final double KLowerSpeedDefault = -1.0;		// was -0.4
    public static final double KClimbSpeedDefault = -1.0;	
   	//public static final double KHoldSpeedDefault  = +0.16;		// Practice bot
    public static final double KHoldSpeedDefault  = +0.12;		// Competition Bot
    public static double KRaiseSpeed, KLowerSpeed, KHoldSpeed;
    public static final double KRaiseSlowSpeed= 0.4;
    public static final double KLowerSlowSpeed= 0;
    public static final double KLimitElevTopPos= 37.5;		// At west valley this was 35 !!    
    //public static final double KLimitElevTopPos= 37.5;		// At west valley this was 35 !!
    public static final double KLimitElevBotPos= 2;
    public static final double BrakeOn = 0;
    public static final double BrakeOff = 1;  
 
    // --------- PID Control Elements ----------------
    
	private static double kTgt_AngleDefault = 0 ;
	private static double kPDefault = 0 ;
	private static double kIDefault = 0 ;
	private static double kDDefault = 0 ;
	private static double kFDefault = 0 ;
	private static double kMaxOutDefault = 0 ;
	private static double kAbs_Tol_Default = 0 ;
	private static double kMoveRtDefault = 0;
	private static double kBBang_UpperDefault = 0 ;
	private static double kBBang_LowerDefault = 0 ; 
	
    static public double K_TGT_ANGLE = 0;			// elev Target Distance
    static public double KP = 0.049;			// elev P constant
    static public double KI = 0.0;				// elev P constant	
    static public double KD = 0.29;				// elev P constant
    static public double KF = 0.0;				// elev P constant
    static public double KMAXOUT = 1.0;			// elev Max Output
    static public double ABS_TOL = 1.0;			// elev Tolerence for Ending
    static public double KMOVERT = 3.6;			// elev Move Rate
    static public double KBBANG_UPPER = 0.4;	
    static public double KBBANG_LOWER = 0.01; 
	
	double kTgt_Angle, kP, kI, kD, kF, kMaxOut, kAbs_Tol, kMoveRt, kBBang_Upper, kBBang_Lower; 

	private SuperPid mSuperPid = null ;
	private double mPID_I;
	private double mPID_R;
	private double mPID_O;
    private double mPID_S; 
    
 	public enum elevPIDMode {NULL, TELE, TOP, BOTTOM, SWITCH, SCALE, START, MOVING, HOLDING, RUNNING,  STOPPED};
    private elevPIDMode melevPIDMode = elevPIDMode.START ;  	// this keeps track of our current drive mode
    
    public enum elevPIDStatus {INIT, RUNNING, DONE, STOPPED, ATEND };
    private elevPIDStatus melevPIDStatus = elevPIDStatus.INIT;

    // --------- Various Constant and Variables ----------------
 	private double mCurrElevPos = 0;					// to be displayed on smartdash
 	private double mDistRemaining = 0;					// Distance remaining to target position
 	private double mCurrElevPwr = 0;					// to be displayed on smartdash
 	private double mCurrElevVolt = 0 ;					// Voltage of Pot
 	private double mLastPos = 0;
 	private int mPrintFlag = 0;							// log voltages once each time lmt sw is hit
 	private int mBrakeFlag = 0;							// 0=Brake Off 1=Brake On
	int overrideFlag;									// 0=No Override of slow moving

	private String line;


    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new ElevByJoystickCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    
    // -- basic constructor
    public ElevSubSys() {
    	mPID_I = 0;
    	mPID_R = 0;
    	mPID_O = 0;
        mPID_S = 0;
        getElevPrefs();
    }


    @Override
    public void periodic() {
        // Put code here to be run every loop
       	updateSmartDash();					// Update elev Position Data and limit switches states
       	updateBrake();

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    // --------------------------------------------
    // --------- Basic Motor Commands -------------
    // --------------------------------------------
      
    //Control Motor Commands
    public void elevStopMtr(){
        mCurrElevPwr = 0;
    	elevMtrCtlr.set(-mCurrElevPwr);
	   	updateSmartDash() ;   	
    }
    public void elevHoldMtr(){
    	if (isLowerLmtSwPressed() == true) {
    		mCurrElevPwr = 0;	
    	} else {
        	mCurrElevPwr = KHoldSpeed ;
    	}
    	elevMtrCtlr.set(-mCurrElevPwr);
	   	updateSmartDash() ;
    }
    
    public void elevBrakeOn() {
    	elevStopMtr();
    }
    
    public void elevBrakeOff() {
    	mBrakeFlag = 0;
		elevBrakeCtlr.set(BrakeOff);
    }    
    
    public void updateBrake() {
    	if (mBrakeFlag == 1)
    		elevBrakeOn();    		
    	else
    		elevBrakeOff();
    }
    
    public void elevMoveMtr(double speed){
    	overrideFlag = Robot.oi.coPilotJoystick.getPOV(0);	// top of POV switch
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed()) {
    		mPrintFlag = 0;	// we have moved off the limit switch     		
    	}
    	if ((speed > KHoldSpeed) && (isUpperLmtSwPressed())) {
			 elevHoldMtr();
			 recalibrateVoltages();
			 return;
    	}
    	if ((speed < KHoldSpeed) && (isLowerLmtSwPressed())){
			recalibrateVoltages();    		
    		elevStopMtr();
    		return;
    	}
    	if (speed == 0) {
			 elevHoldMtr();    		
    	}

		mCurrElevPwr = speed;
		
    	if(mCurrElevPwr > KHoldSpeed) {
			//Speed is greater than hold so we are rising
    		if((getElevPos()>= KLimitElevTopPos) && (mCurrElevPwr>= KRaiseSlowSpeed) && (overrideFlag!=0)) {
    			mCurrElevPwr= KRaiseSlowSpeed;
    		}
		}
		 // This is for slowing down as we reach bottom
    	if(mCurrElevPwr < KHoldSpeed) {
    		//speed is less than hold so we are lowering
    		if((getElevPos()<= KLimitElevBotPos) && (mCurrElevPwr <= KLowerSlowSpeed) && (overrideFlag!=0)) {
        		mCurrElevPwr= KLowerSlowSpeed;
        	}
    	}

		if(mBrakeFlag== 0) elevMtrCtlr.set(-mCurrElevPwr);
	   	updateSmartDash() ;
    }
    
    
    public void elevLower() {
    	mCurrElevPwr = KLowerSpeed;
    	overrideFlag = Robot.oi.coPilotJoystick.getPOV(0);	// top of POV switch
    	if (isLowerLmtSwPressed()){  		
    		elevStopMtr();
			recalibrateVoltages();  
    		return;
    	}
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed()) mPrintFlag = 0;	// we have moved off the limit switch     		
    	if((getElevPos()<= KLimitElevBotPos) && (mCurrElevPwr<= KLowerSlowSpeed) && (overrideFlag!=0)) {
    		mCurrElevPwr= KLowerSlowSpeed;
    	}
    	elevBrakeOff();
		elevMtrCtlr.set(-mCurrElevPwr);
	   	updateSmartDash() ;    	
    }
    
    public void elevRaise() {
    	mCurrElevPwr = KRaiseSpeed;
    	overrideFlag = Robot.oi.coPilotJoystick.getPOV(0);	// top of POV switch
    	if (isUpperLmtSwPressed()) {
			 elevHoldMtr();
			 recalibrateVoltages();
			 return;
    	}
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed()) mPrintFlag = 0;	// we have moved off the limit switch 
    	if((getElevPos()>= KLimitElevTopPos) && (mCurrElevPwr>= KRaiseSlowSpeed) && (overrideFlag!=0)) {
    		mCurrElevPwr= KRaiseSlowSpeed;
    	}
    	
    	//  This is for slowing down as we reach bottom
    	elevBrakeOff();
		elevMtrCtlr.set(-mCurrElevPwr);
	   	updateSmartDash() ;     	
    }
    // -------------------------------------
    // ---------  Get Sensor  Data ---------
    // -------------------------------------
    public boolean isUpperLmtSwPressed() {
 	   if (elevUpperLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isUpperLmtSwNotPressed() {
 	   if (elevUpperLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwPressed() {
 	   if (elevLwrLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwNotPressed() {
 	   if (elevLwrLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
     
    public double getPot(){
    	mCurrElevVolt = elevPotentiometer.get() ;
   	 	return mCurrElevVolt;
   } 
    public double getElevPos(){
    	double currPot =  getPot();
    	//mCurrElevPos = ( getPot() - kBotVolt ) / ELEV_POT_CONV * -1;
    	mCurrElevPos = (( kBotVolt - currPot) / ELEV_POT_CONV) ;
    	mCurrElevPos = Rmath.mRound(mCurrElevPos , 1);		// Round to 1 decimal digits
    	return Rmath.mRound(mCurrElevPos, 2);
    }
    
    public void recalibrateVoltages(){
    	// Self calibration method. Each time we hit the limit switch re-calibrate voltages
     	if 		(isUpperLmtSwPressed() ) {
    		kTopVolt = getPot() ;
    		line = "Elev Upper Limit Switch hit - ";
    	}
    	if (isLowerLmtSwPressed() ) {
    		kBotVolt = getPot() ;
    		line = "Elev Upper Limit Switch hit - ";
    	}
    	kVoltDiff = kBotVolt - kTopVolt;
    	ELEV_POT_CONV = kVoltDiff / ELEV_TOTAL_DIST; //Volts/degree
    	double pos = getElevPos();
    	if (mPrintFlag == 0) {
    		mPrintFlag = 1; 		// lets not immediately reprint values
    		mLastPos = pos;
    		line += (" kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt +
                     " VOLT DIFF =" + kVoltDiff + " ElevPos=" + pos);
    		Robot.logger.appendLog(line);
    		System.out.println(line);
    	}
    }
    
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -----------------------
    public void getElevPrefs() {
        // grab the relevant coefficients from preferences
    	kTgt_Angle =	Robot.prefs.getDouble("elev_10_PID_Tgt", kTgt_AngleDefault) ;
    	kP	= 	Robot.prefs.getDouble		("elev_20_PID_P", kPDefault) ;
    	kI	= 	Robot.prefs.getDouble		("elev_21_PID_I", kIDefault) ;
    	kD = 	Robot.prefs.getDouble		("elev_22_PID_D", kDDefault) ;
    	kF = 	Robot.prefs.getDouble		("elev_23_PID_F", kFDefault) ;
    	
    	kAbs_Tol = Robot.prefs.getDouble	("elev_30_PID_Tol_In", kAbs_Tol_Default);    	
    	kMoveRt = Robot.prefs.getDouble		("elev_31_PID_MoveRt",kMoveRtDefault);        
    	kBBang_Lower = Robot.prefs.getDouble("elev_32_BB_Lwr",kBBang_LowerDefault);
    	kBBang_Upper = Robot.prefs.getDouble("elev_33_PID_BB_Upr",kBBang_UpperDefault);
    	kMaxOut = Robot.prefs.getDouble		("elev_34_PID_MaxOut", kMaxOutDefault);  

    	// Init Potentiometer voltage points upon startup
    	kTopVolt = Robot.prefs.getDouble	("elev_40_Volt_Upper", kTopVoltDefault) ;
    	kBotVolt = Robot.prefs.getDouble	("elev_41_Volt_Lower", kBotVoltDefault) ;    	
    	if (isUpperLmtSwPressed()) {
    		kTopVolt =  getPot() ;					// if Robot Elev starts at Top calibrate at this time
    	} else if (isLowerLmtSwPressed()) {
    		kBotVolt =  getPot() ;					// if Robot Elev starts at Bottom calibrate at this time	
    	}
    	kVoltDiff = kBotVolt - kTopVolt ;
    	ELEV_POT_CONV = (kVoltDiff / ELEV_TOTAL_DIST); //Volts per inch
    	line = ("Elev Init kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt + " ELEV_TOTAL_DIST=" + ELEV_TOTAL_DIST);
    	Robot.logger.appendLog(line);
    	System.out.println(line);

    	KRaiseSpeed  = Robot.prefs.getDouble	("elev_50_Raise_Pwr", KRaiseSpeedDefault) ;
    	KLowerSpeed = Robot.prefs.getDouble		("elev_51_Lower_Pwr", KLowerSpeedDefault) ;
    	KHoldSpeed = Robot.prefs.getDouble		("elev_52_Hold_Pwr", KHoldSpeedDefault) ;
    	// remove next 3 lines afet getting these into prefs
    	KRaiseSpeed  = KRaiseSpeedDefault ;
    	KLowerSpeed = KLowerSpeedDefault ;
    	KHoldSpeed =  KHoldSpeedDefault ;    	
    }
    


   // ***********************************************************************
   // 							PID Routines
   // ***********************************************************************

   // a Command can call this to drive elevator to position (Inches)
   public void driveElevByPID(double position) {
	   melevPIDMode = elevPIDMode.MOVING;						// record that we're in PID mode
	   getElevPrefs();										// Get all Constants from preferences
	   kTgt_Angle = position;									// overwrite smartdashboard position
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new elevPid(kTgt_Angle, kP, kI, kD, kF);		// create PID / default values
       Robot.logger.appendLog("**** elev Pid Stopping *** ");
       logStartData();       
       mSuperPid.start();       							// start the PID IO (and the PID)
 	}

   // a Command can call this to drive elevator to position (Inches)
   public void driveElevByPIDTest() {
	   System.out.println("Entering driveelevByPIDTest");
	   melevPIDMode = elevPIDMode.MOVING;						// record that we're in PID mode
	   getElevPrefs();										// Get all Constants from preferences
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new elevPid(kTgt_Angle, kP, kI, kD, kF);		// create PID / default values
       Robot.logger.appendLog("**** elev Pid Stopping *** ");
       logStartData();
	   mSuperPid.start();       							// start the PID IO (and the PID)
 	}
   
   // a Command can call this to see if we're done
   public elevPIDMode getElevPIDMode() {   
	   return melevPIDMode ;   
   }
    
   // a Command can call this to force a stop (e.g., from a watchdog timer)    
	public void stopPID() {
		// stop the drive motors and shutdown automation
		//System.out.println("****** STOPPING AUTOMATION *****") ;
	    Robot.logger.appendLog("**** elev Pid Stopping *** ");
		if (mSuperPid !=null) {
			mSuperPid.stop();
			// Don't delete superPid object because it can leave PID controller unreachable to disable !!!		
		 	//mSuperPid  = null ;			
		}
		melevPIDMode = elevPIDMode.TELE ;
		elevStopMtr();
	}
   
	// --------------------------------------------------------------------------------
	// Input and Output for Elevator PID controller
	// --------------------------------------------------------------------------------
	private class elevPid extends SuperPid 
	{
       // constructor - Set Options for SuperPid here !!!
       public elevPid(double kDIST, double KP, double KI, double KD, double KF) {
           super(kDIST, KP, KI, KD, KF);
           mOptions.setTolerance(kAbs_Tol);								// Set Tolerance
           mOptions.setKeepRunningCriteria(false, kAbs_Tol) ;			// Set to stop at setpoint
           mOptions.setRamping(false, 0);							// Do Not use ramping
       }

       @Override
       public void applyPidOutput(double output) {
    	   mCurrElevPwr = output;
    	   elevMoveMtr(output);
           logData();
       }

       @Override
       public double getPidInput() {
           // these are in inches
           return getElevPos();
       }
       
       @Override
       public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut,  double setpoint) {
           if (status == PidStatus.RUNNING) {
               melevPIDStatus = elevPIDStatus.RUNNING;
               mPID_I = input ;
               mPID_R = rawOutput ;
               mPID_O = pidOut ;
               mPID_S = setpoint ;
           } else if (status == PidStatus.STOPPED) {
               melevPIDStatus = elevPIDStatus.STOPPED;
               elevStopMtr();	// The pid never sends a stop .. so motor continues running
               return;
           } else if (status == PidStatus.ATEND) {
               melevPIDStatus = elevPIDStatus.ATEND;            	
               return;
           }
       }
	}

	
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -------------------


	// ------------------- SmartDash board Methods ------------------------------------------
	public void updateSmartDash() {
     	if( isLowerLmtSwPressed())
        	SmartDashboard.putString("elev LowerLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("elev LowerLmtSw", "NOT Pressed") ;
     	
     	if( isUpperLmtSwPressed())
        	SmartDashboard.putString("elev UpperLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("elev UpperLmtSw", "NOT Pressed") ;
     
     	if( mBrakeFlag == 0)
        	SmartDashboard.putString("Elev Brake","OFF") ;
     	else
     		SmartDashboard.putString("Elev Brake", "*** ON ***") ;
     	
     	SmartDashboard.putNumber("elev CurrPos", Rmath.mRound(getElevPos(),2)) ;
     	SmartDashboard.putNumber("elev CurrVolt", Rmath.mRound(getPot(), 3)) ;     	
     	SmartDashboard.putNumber("elev CurrPwr", mCurrElevPwr) ;
	}
	
	public void logData() {
		line =  "Debug - elev PID,";
    	line += " Tgt=," + kTgt_Angle;
    	line += " , Remaing Dist=," + (kTgt_Angle - mCurrElevPos);
    	line += " , CurrPos=," + Rmath.mRound(mCurrElevPos, 2);
    	line += " , CurrVolt=," + Rmath.mRound(mCurrElevVolt, 3);    	
    	line += " , PidOut=," + mCurrElevPwr;    	
    	line += " , LmtSw UL=,";
    	if (isUpperLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	if (isLowerLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}
	
	public void logStartData() {
		line =  "Debug - elev PID STARTING,";
    	line += " Tgt=," + kTgt_Angle;		
    	line += " P=," + kP;
    	line += " I=," + kI;
    	line += " D=," + kD;
    	line += " F=," + kF;
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}	
}

