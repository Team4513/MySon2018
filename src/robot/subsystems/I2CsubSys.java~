// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.subsystems;

import robot.RobotMap;
import robot.commands.*;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 * PHS Sept 30, 2017
 *     This is a generic Robobuilder subsystem wrapper for the WpiLib I2C class.
 *     In this case this single subsystem can be used to communicate to multiple I2C
 *     devices (addresses), but the caller will want to set the response buffer size
 *     appropriately before sending data to a device.
 *     An alternative would be to fix the address and buffer size at construction time
 *     and dedicate a subsystem for each device. That would require some minor changes
 *     to this code. 
 */
public class I2CsubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // for transaction response from the device (response data must have a fixed size)
    // default to a three byte response (room for a 2 char zt string)
	// this can be changed by calling setResponseBufSize() below
    private byte[] m_response = {'X','X','\0'} ;

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public I2CsubSys() {
	   // SmartDashboard.putString("I2C Debug", "MyI2C construct");
    }
    
    // should always set the response buffer size before initiating communication
    // with a new device
    public boolean setResponseBufSize(int n) {
    	if (n<0) return false ;
    	m_response = new byte[n] ;
    	return true ;
    }
    
	// send String data
    public boolean sendString(int address, String strdata) {
        I2C i2c = new I2C(I2C.Port.kOnboard, address);
        
        // Java String is not just a zero-terminated array, so we need to convert it to one
    	// We could leave the terminator off, but we're leaving it in as a convenience to the
    	// receiving device. Java makes that a tad tricky.
    	byte[] buf=strdata.getBytes();
    	byte[] bufzt=new byte[buf.length+1];
    	System.arraycopy(buf, 0, bufzt, 0, buf.length);
    	bufzt[buf.length] = '\0' ;
    	
    	// clear the response buffer
    	for (int i=0 ; i<m_response.length ; i++)
    		m_response[i] = '\0' ;
    	
    	// now we can send it
    	// bizarrely, this call returns false for success, true for failure!
    	boolean failure ;
    	if (m_response.length>0)
    		failure = i2c.transaction(bufzt, bufzt.length, m_response, m_response.length) ;
    	else
    		failure = i2c.writeBulk(bufzt) ;
    	return !failure ;
    }
    
    // get String response
    public String getLastResponseAsString( ) {
    	if (m_response.length>0)
           return new String(m_response) ;
    	else 
    	   return "NONE" ;
    }
    
	// send Byte data
    public boolean sendBytes(int address, byte[] bytes) {
        I2C i2c = new I2C(I2C.Port.kOnboard, address);
        
    	// clear the response buffer
    	for (int i=0 ; i<m_response.length ; i++)
    		m_response[i] = 0 ;
    	
    	// now we can send it
    	boolean failure ;
    	if (m_response.length>0)
    		failure = i2c.transaction(bytes, bytes.length, m_response, m_response.length) ;   
    	else
    		failure = i2c.writeBulk(bytes) ;
    	return !failure ;
    }

    // get byte array response
    public byte[] getLastResponseAsBytes( ) {
        return m_response ;    	
    }
}

